Future Directions

> As computing degeneracy ordering takes a significant portion of the total time,
  degree decreasing or increasing ordering is used in practice.

* comment: not the case, efficient to compute

> How to efficiently update the number of triangles after
deleting one edge (u,v)?
>
> â–  Intersect the neighbor-sets of u and v in min{d(u), d(v)}  time

* **How to do truss decomposition without hash tables**?
* What is the relationship between dense subgraphs with
different density (average degree) values?
* How to scale up nucleus decomposition and k-clique densest
subgraphs for large k values?
* How to effectively and efficiently incorporate other information
(such as attributes, temporal) into dense subgraph computation?